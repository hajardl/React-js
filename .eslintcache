[{"C:\\Users\\hajar\\project\\src\\index.js":"1","C:\\Users\\hajar\\project\\src\\App.js":"2","C:\\Users\\hajar\\project\\src\\reportWebVitals.js":"3","C:\\Users\\hajar\\project\\src\\table.js":"4","C:\\Users\\hajar\\project\\src\\useContactsTable.js":"5","C:\\Users\\hajar\\project\\src\\useApi.js":"6"},{"size":272,"mtime":1611413178989,"results":"7","hashOfConfig":"8"},{"size":2164,"mtime":1611414837704,"results":"9","hashOfConfig":"8"},{"size":362,"mtime":499162500000,"results":"10","hashOfConfig":"8"},{"size":309,"mtime":1611408398976,"results":"11","hashOfConfig":"8"},{"size":5503,"mtime":1611410632157,"results":"12","hashOfConfig":"8"},{"size":2667,"mtime":1611409451049,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"jt36a1",{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"28"},"C:\\Users\\hajar\\project\\src\\index.js",["29"],"C:\\Users\\hajar\\project\\src\\App.js",[],"C:\\Users\\hajar\\project\\src\\reportWebVitals.js",[],["30","31"],"C:\\Users\\hajar\\project\\src\\table.js",[],"C:\\Users\\hajar\\project\\src\\useContactsTable.js",["32"],"C:\\Users\\hajar\\project\\src\\useApi.js",["33","34","35","36","37","38","39"],"import isEqual from \"lodash/isEqual\";\r\nimport memoize from \"lodash/memoize\";\r\nimport { useEffect, useState, useCallback, useMemo , useHooks } from 'react';\r\n\r\n\r\nexport default function useApi(url, options = {}) {\r\n  const [previousOptions, setOptions] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [results, setResults] = useState(null);\r\n  const [error, setError] = useState(null);\r\n\r\n  let unmounted = false;\r\n\r\n  // Converts the URL and params to a string for use by the cache.\r\n  const resolver = useCallback(\r\n    (url, params) => `{\"${url}\": ${JSON.stringify(params)}}`,\r\n    []\r\n  );\r\n\r\n  // The fetch function is what actually retrieves data from the server.\r\n  // We call useMemo because it only needs to be created once, otherwise\r\n  // the cache will always be empty. We memoize it so that repeated calls\r\n  // to the same url/params will return the results from the last call.\r\n  const memoFetch = useMemo(\r\n    () =>\r\n      memoize(\r\n        (url, params) => fetch(url, params).then(res => res.json()),\r\n        resolver\r\n      ),\r\n    []\r\n  );\r\n\r\n  // Remove the currently fetched page from the cache so that when it\r\n  // refetches, it will hit the server again.\r\n  const refetch = useCallback(\r\n    () => {\r\n      memoFetch.cache.delete(resolver(url, options));\r\n      setOptions(null);\r\n    },\r\n    [url, options]\r\n  );\r\n\r\n  // Clear the whole cache so that every request will hit the server again.\r\n  const invalidate = useCallback(() => {\r\n    memoFetch.cache.clear();\r\n    setOptions(null);\r\n  }, []);\r\n\r\n  useEffect(\r\n    () => {\r\n      if (isEqual(options, previousOptions)) return;\r\n\r\n      async function fetchData() {\r\n        if (unmounted) return;\r\n\r\n        try {\r\n          setLoading(true);\r\n          const res = await memoFetch(url, options);\r\n          if (unmounted) return;\r\n\r\n          setResults(res);\r\n          setError(null);\r\n        } catch (err) {\r\n          setError(err);\r\n        }\r\n\r\n        setLoading(false);\r\n      }\r\n\r\n      setOptions(options);\r\n      fetchData();\r\n    },\r\n    [url, options]\r\n  );\r\n\r\n  // Caller can force invalidation by passing in an \"invalidate\" prop\r\n  useEffect(\r\n    () => {\r\n      if (options.invalidate) {\r\n        invalidate();\r\n      }\r\n    },\r\n    [options.invalidate]\r\n  );\r\n\r\n  // Changing the URL triggers a full update\r\n  useEffect(\r\n    () => {\r\n      setOptions(null);\r\n    },\r\n    [url]\r\n  );\r\n\r\n  // This is a bit of a hack since we don't expose a way to cancel the request\r\n  useEffect(\r\n    () => () => {\r\n      unmounted = true;\r\n    },\r\n    []\r\n  );\r\n\r\n  return {\r\n    loading,\r\n    results,\r\n    error,\r\n    refetch,\r\n    invalidate\r\n  };\r\n}\r\n",["40","41"],{"ruleId":"42","severity":1,"message":"43","line":5,"column":8,"nodeType":"44","messageId":"45","endLine":5,"endColumn":23},{"ruleId":"46","replacedBy":"47"},{"ruleId":"48","replacedBy":"49"},{"ruleId":null,"fatal":true,"severity":2,"message":"50","line":46,"column":10},{"ruleId":"42","severity":1,"message":"51","line":3,"column":54,"nodeType":"44","messageId":"45","endLine":3,"endColumn":62},{"ruleId":"52","severity":1,"message":"53","line":30,"column":5,"nodeType":"54","endLine":30,"endColumn":7,"suggestions":"55"},{"ruleId":"52","severity":1,"message":"56","line":40,"column":5,"nodeType":"54","endLine":40,"endColumn":19,"suggestions":"57"},{"ruleId":"52","severity":1,"message":"58","line":47,"column":6,"nodeType":"54","endLine":47,"endColumn":8,"suggestions":"59"},{"ruleId":"52","severity":1,"message":"60","line":73,"column":5,"nodeType":"54","endLine":73,"endColumn":19,"suggestions":"61"},{"ruleId":"52","severity":1,"message":"62","line":83,"column":5,"nodeType":"54","endLine":83,"endColumn":25,"suggestions":"63"},{"ruleId":"52","severity":1,"message":"64","line":97,"column":19,"nodeType":"65","endLine":97,"endColumn":23},{"ruleId":"46","replacedBy":"66"},{"ruleId":"48","replacedBy":"67"},"no-unused-vars","'reportWebVitals' is defined but never used.","Identifier","unusedVar","no-native-reassign",["68"],"no-negated-in-lhs",["69"],"Parsing error: Identifier 'Fragment' has already been declared\n\n\u001b[0m \u001b[90m 44 | \u001b[39m\u001b[36mimport\u001b[39m \u001b[33mReact\u001b[39m from \u001b[32m\"react\"\u001b[39m\u001b[33m;\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 45 | \u001b[39m\u001b[36mimport\u001b[39m \u001b[33mReactDOM\u001b[39m from \u001b[32m\"react-dom\"\u001b[39m\u001b[33m;\u001b[39m\u001b[0m\n\u001b[0m\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 46 | \u001b[39m\u001b[36mimport\u001b[39m { \u001b[33mFragment\u001b[39m\u001b[33m,\u001b[39m useState\u001b[33m,\u001b[39m useEffect\u001b[33m,\u001b[39m \u001b[33mComponent\u001b[39m \u001b[33m,\u001b[39museTable\u001b[33m,\u001b[39m useHooks } from \u001b[32m'react'\u001b[39m\u001b[33m;\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m    | \u001b[39m         \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 47 | \u001b[39m\u001b[36mimport\u001b[39m {\u001b[33mTable\u001b[39m\u001b[33m,\u001b[39m \u001b[33mColumn\u001b[39m\u001b[33m,\u001b[39m \u001b[33mCell\u001b[39m} from \u001b[32m'fixed-data-table'\u001b[39m\u001b[33m;\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 48 | \u001b[39m\u001b[36mimport\u001b[39m useContactsTable from \u001b[32m\"./useContactsTable\"\u001b[39m\u001b[33m;\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 49 | \u001b[39m\u001b[0m","'useHooks' is defined but never used.","react-hooks/exhaustive-deps","React Hook useMemo has a missing dependency: 'resolver'. Either include it or remove the dependency array.","ArrayExpression",["70"],"React Hook useCallback has missing dependencies: 'memoFetch.cache' and 'resolver'. Either include them or remove the dependency array.",["71"],"React Hook useCallback has a missing dependency: 'memoFetch.cache'. Either include it or remove the dependency array.",["72"],"React Hook useEffect has missing dependencies: 'memoFetch', 'previousOptions', and 'unmounted'. Either include them or remove the dependency array.",["73"],"React Hook useEffect has a missing dependency: 'invalidate'. Either include it or remove the dependency array.",["74"],"Assignments to the 'unmounted' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","Literal",["68"],["69"],"no-global-assign","no-unsafe-negation",{"desc":"75","fix":"76"},{"desc":"77","fix":"78"},{"desc":"79","fix":"80"},{"desc":"81","fix":"82"},{"desc":"83","fix":"84"},"Update the dependencies array to be: [resolver]",{"range":"85","text":"86"},"Update the dependencies array to be: [memoFetch.cache, resolver, url, options]",{"range":"87","text":"88"},"Update the dependencies array to be: [memoFetch.cache]",{"range":"89","text":"90"},"Update the dependencies array to be: [url, options, previousOptions, unmounted, memoFetch]",{"range":"91","text":"92"},"Update the dependencies array to be: [invalidate, options.invalidate]",{"range":"93","text":"94"},[1079,1081],"[resolver]",[1346,1360],"[memoFetch.cache, resolver, url, options]",[1547,1549],"[memoFetch.cache]",[2060,2074],"[url, options, previousOptions, unmounted, memoFetch]",[2259,2279],"[invalidate, options.invalidate]"]